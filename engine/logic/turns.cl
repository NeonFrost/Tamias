;;;;Speed difference is the difference between the current and next entity (i.e. Vanya-speed - socra-speed)
;;;;the difference is taken away from the current entity's speed and tested against the next entity's speed
(defmacro agility-test (obj1 obj2)
  `(let ((a1 (entity-agility ,obj1))
	 (a2 (entity-agility ,obj2)))
     (if (> a1 a2)
	 t)))

(defun set-turn-order ()
  (let* ((test (append (list player) creatures))
	 (temp-order (list (nth 0 test))))
    (setf turn-order (list (list 'c 0)))
    (loop for n from 1 to (1- (length test))
       do (loop for y below (length turn-order)
	     do (let ((obj (if (creature-p (nth n test))
			       (list 'c n)
			       (list 'p (- n (length creatures))))))
		  (if (agility-test (nth n test) (nth y temp-order))
		      (if (eq y 0)
			  (return (progn (push obj turn-order)
					 (push (nth n test) temp-order)
					 (princ "fastest") (fresh-line)))
			  (return (progn (push (nth n test) (cdr (nthcdr (1- y) temp-order)))
					 (push obj (cdr (nthcdr (1- y) turn-order)))
					 (princ "Not as Fast, but still fucking fast") (fresh-line))))
		      (if (eq y (1- (length turn-order)))
			  (return (progn (setf temp-order (append temp-order (list (nth n test))))
					 (setf turn-order (append turn-order (list obj)))
					 (princ "slower than my brother") (fresh-line)))
			  ))))
	 (princ temp-order) (princ "        ") (princ turn-order) (fresh-line))))

(defun end-turn ()
  (setf sub-state 'top)
  (incf current-turn 1)
  (if (> current-turn (1- (length turn-order)))
      (progn (setf current-turn 0)
	     (set-turn-order)))
  )

(defun player-turn ()
  (setf state 'level)
  (setf sub-state 'top)
  (test-spawn)
  (reset-text-buffer enemy-buffer)
  (reset-text-buffer status-buffer))

(defun creature-turn (creature)
  (case (creature-behavior creature)
    (aggresive (if (player-is-within-attack-range)
		   (attack player)))
    (defensive (if (< (entity-hp creature) (entity-max-hp creature))
		   (if (player-is-within-attack-range)
		       (attack player)
		       (run-away))
		   (wander)))
    (passive (if (< (entity-hp creature) (entity-max-hp creature))
		 (run-away)
		 (wander)))
    (berserk (if (player-is-within-attack-range)
		 (attack player)
		 (if (other-creatures-are-within-attack-range)
		     (attack creature)
		     (move-to-closest-entity))))
    ))

(defun check-turn ()
  (if (or (eq (car (nth current-turn turn-order)) 'm)
	  (eq (car (nth current-turn turn-order)) 'c))
      (creature-turn (nth (cadr (nth current-turn turn-order)) enemies-list))
      (player-turn)))

#|
(defun test-turn (entity-1 entity-2)
  (if 
  (setf current-turn (nth entities entity-1))
      (setf current-turn (nth entities entity-2))
      )
  )
|#
